(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{606:function(t,r,a){"use strict";a.r(r);var e=a(13),o=Object(e.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"笔记"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#笔记"}},[t._v("#")]),t._v(" 笔记")]),t._v(" "),a("h2",{attrs:{id:"from-future-import-unicode-literals"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#from-future-import-unicode-literals"}},[t._v("#")]),t._v(" from future import unicode_literals")]),t._v(" "),a("p",[t._v("从Python 2.7到Python 3.x有不兼容的一些改动，比如2.x里的字符串用'xxx'表示str，\nUnicode字符串用u'xxx'表示unicode，而在3.x中，所有字符串都被视为unicode，因此，\n写u'xxx'和'xxx'是完全一致的，而在2.x中以'xxx'表示的str就必须写成b'xxx'，以此\n表示“二进制字符串”。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("为了适应Python 3.x的新的字符串的表示方法，在2.7版本的代码中，可以通过\n")])])]),a("p",[t._v("unicode_literals来使用Python 3.x的新的语法：在python3中默认的编码采用了unicode,\n并取消了前缀u. 如果代码要兼容python2/3")]),t._v(" "),a("h2",{attrs:{id:"from-future-import-absolute-import"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#from-future-import-absolute-import"}},[t._v("#")]),t._v(" from "),a("strong",[t._v("future")]),t._v(" import absolute_import")]),t._v(" "),a("p",[t._v("导入系统的绝对路径，而不是想对路径，避免重名带来的import错误")]),t._v(" "),a("h2",{attrs:{id:"from-future-import-division"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#from-future-import-division"}},[t._v("#")]),t._v(" from "),a("strong",[t._v("future")]),t._v(" import division")]),t._v(" "),a("p",[t._v("使用python3的除法，而不是python2的截断除法")]),t._v(" "),a("h2",{attrs:{id:"from-future-import-print-function"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#from-future-import-print-function"}},[t._v("#")]),t._v(" from "),a("strong",[t._v("future")]),t._v(" import print_function")]),t._v(" "),a("p",[t._v("使用python3的print函数")]),t._v(" "),a("h2",{attrs:{id:"ast-literal-eval"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ast-literal-eval"}},[t._v("#")]),t._v(" ast.literal_eval")]),t._v(" "),a("p",[t._v("规避eval函数带来的风险，功能与eval函数，将字符串转换成相应的数据类型。")]),t._v(" "),a("h2",{attrs:{id:"python-下划线"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#python-下划线"}},[t._v("#")]),t._v(" python 下划线")]),t._v(" "),a("p",[t._v("使用单下划线(_one_underline)开头表示方法不是API的一部分，不要直接访问（虽然语法上访问也没有什么问题）。")]),t._v(" "),a("p",[t._v("使用双下划线开头(__two_underlines)开头表示子类不能覆写该方法。除非你真的知道你在干什么，否则不要使用这种方式。")]),t._v(" "),a("p",[t._v("当你想让自己定义的对象也可以像Python内置的对象一样使用Python内置的一些函数或操作符（比如len、add、+、-、==等）时，你可以定义该类方法。")]),t._v(" "),a("p",[t._v("当然还有些属性只在末尾加了但下划线，这仅仅是为了避免我们起的一些名字和Python保留关键字冲突，没有特殊含义。")]),t._v(" "),a("h2",{attrs:{id:"all"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#all"}},[t._v("#")]),t._v(" "),a("strong",[t._v("all")])]),t._v(" "),a("p",[t._v("python模块中的__all__属性，可用于模块导入时限制，如：\nfrom module import *\n此时被导入模块若定义了__all__属性，则只有__all__内指定的属性、方法、类可被导入。\n若没定义，则导入模块内的所有公有属性，方法和类 。")]),t._v(" "),a("h2",{attrs:{id:"yapf"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#yapf"}},[t._v("#")]),t._v(" yapf")]),t._v(" "),a("p",[t._v("利用yapf将python代码编写分割弄成pep8规范\n"),a("code",[t._v("pip install yapf")]),t._v(" "),a("code",[t._v("yapf -r -i <file_name>")])]),t._v(" "),a("p",[t._v("对于github的repo可以安装pre_commit，这样每次commit的时候会进行检查")]),t._v(" "),a("div",{staticClass:"language-buildoutcfg extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("pip install pre_commit\n \npre-commit install\n \n# 如果出现pre-commit安装出现SSL错误\n请执行\ngit config --global http.sslVerify false\n")])])])])}),[],!1,null,null,null);r.default=o.exports}}]);