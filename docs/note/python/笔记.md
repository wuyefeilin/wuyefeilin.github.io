# 笔记

## from future import unicode_literals

从Python 2.7到Python 3.x有不兼容的一些改动，比如2.x里的字符串用'xxx'表示str，
Unicode字符串用u'xxx'表示unicode，而在3.x中，所有字符串都被视为unicode，因此，
写u'xxx'和'xxx'是完全一致的，而在2.x中以'xxx'表示的str就必须写成b'xxx'，以此
表示“二进制字符串”。

    为了适应Python 3.x的新的字符串的表示方法，在2.7版本的代码中，可以通过
unicode_literals来使用Python 3.x的新的语法：在python3中默认的编码采用了unicode, 
并取消了前缀u. 如果代码要兼容python2/3

## from __future__ import absolute_import
导入系统的绝对路径，而不是想对路径，避免重名带来的import错误

## from __future__ import division
使用python3的除法，而不是python2的截断除法

## from __future__ import print_function
使用python3的print函数

## ast.literal_eval
规避eval函数带来的风险，功能与eval函数，将字符串转换成相应的数据类型。

## python 下划线
使用单下划线(_one_underline)开头表示方法不是API的一部分，不要直接访问（虽然语法上访问也没有什么问题）。

使用双下划线开头(__two_underlines)开头表示子类不能覆写该方法。除非你真的知道你在干什么，否则不要使用这种方式。

当你想让自己定义的对象也可以像Python内置的对象一样使用Python内置的一些函数或操作符（比如len、add、+、-、==等）时，你可以定义该类方法。

当然还有些属性只在末尾加了但下划线，这仅仅是为了避免我们起的一些名字和Python保留关键字冲突，没有特殊含义。

## __all__
python模块中的__all__属性，可用于模块导入时限制，如：
from module import *
此时被导入模块若定义了__all__属性，则只有__all__内指定的属性、方法、类可被导入。
若没定义，则导入模块内的所有公有属性，方法和类 。

## yapf
利用yapf将python代码编写分割弄成pep8规范
`pip install yapf`
`yapf -r -i <file_name>`

对于github的repo可以安装pre_commit，这样每次commit的时候会进行检查
```buildoutcfg
pip install pre_commit
 
pre-commit install
 
# 如果出现pre-commit安装出现SSL错误
请执行
git config --global http.sslVerify false
```



